// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: api/v1/purchase.proto

package apipb

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	io "io"
	ioutil "io/ioutil"
	mime "mime"
	http "net/http"
	strings "strings"
)

// PurchaseServiceHTTPService is the server API for PurchaseService service.
type PurchaseServiceHTTPService interface {
	InitializePurchaseAlipay(context.Context, *InitializePurchaseAlipayRequest) (*InitializePurchaseAlipayResponse, error)
	ValidatePurchaseAlipay(context.Context, *ValidatePurchaseAlipayRequest) (*ValidatePurchaseAlipayResponse, error)
	CancelPurchase(context.Context, *CancelPurchaseRequest) (*CancelPurchaseResponse, error)
}

// PurchaseServiceHTTPConverter has a function to convert PurchaseServiceHTTPService interface to http.HandlerFunc.
type PurchaseServiceHTTPConverter struct {
	srv PurchaseServiceHTTPService
}

// NewPurchaseServiceHTTPConverter returns PurchaseServiceHTTPConverter.
func NewPurchaseServiceHTTPConverter(srv PurchaseServiceHTTPService) *PurchaseServiceHTTPConverter {
	return &PurchaseServiceHTTPConverter{
		srv: srv,
	}
}

// InitializePurchaseAlipay returns PurchaseServiceHTTPService interface's InitializePurchaseAlipay converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) InitializePurchaseAlipay(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) http.HandlerFunc {
	if onError == nil {
		onError = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					options := protojson.MarshalOptions{UseProtoNames: true}
					buf, err := options.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == "" {
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		arg := &InitializePurchaseAlipayRequest{}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				onError(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := protojson.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				onError(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/appsets.api.v1.PurchaseService/InitializePurchaseAlipay",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.InitializePurchaseAlipay(c, req.(*InitializePurchaseAlipayRequest))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			onError(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*InitializePurchaseAlipayResponse)
		if !ok {
			onError(ctx, w, r, arg, nil, fmt.Errorf("/appsets.api.v1.PurchaseService/InitializePurchaseAlipay: interceptors have not return InitializePurchaseAlipayResponse"))
			return
		}

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			options := protojson.MarshalOptions{UseProtoNames: true}
			buf, err := options.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			onError(ctx, w, r, arg, ret, err)
			return
		}
		onError(ctx, w, r, arg, ret, nil)
	})
}

// InitializePurchaseAlipayWithName returns Service name, Method name and PurchaseServiceHTTPService interface's InitializePurchaseAlipay converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) InitializePurchaseAlipayWithName(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	return "PurchaseService", "InitializePurchaseAlipay", h.InitializePurchaseAlipay(onError, interceptors...)
}

// InitializePurchaseAlipayHTTPRule returns HTTP method, path and PurchaseServiceHTTPService interface's InitializePurchaseAlipay converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) InitializePurchaseAlipayHTTPRule(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	if onError == nil {
		onError = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					options := protojson.MarshalOptions{UseProtoNames: true}
					buf, err := options.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.MethodPost, "/api/v1/purchase/alipay/initialize", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == "" {
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		arg := &InitializePurchaseAlipayRequest{}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				onError(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := protojson.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				onError(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/appsets.api.v1.PurchaseService/InitializePurchaseAlipay",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.InitializePurchaseAlipay(c, req.(*InitializePurchaseAlipayRequest))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			onError(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*InitializePurchaseAlipayResponse)
		if !ok {
			onError(ctx, w, r, arg, nil, fmt.Errorf("/appsets.api.v1.PurchaseService/InitializePurchaseAlipay: interceptors have not return InitializePurchaseAlipayResponse"))
			return
		}

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			options := protojson.MarshalOptions{UseProtoNames: true}
			buf, err := options.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			onError(ctx, w, r, arg, ret, err)
			return
		}
		onError(ctx, w, r, arg, ret, nil)
	})
}

// ValidatePurchaseAlipay returns PurchaseServiceHTTPService interface's ValidatePurchaseAlipay converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) ValidatePurchaseAlipay(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) http.HandlerFunc {
	if onError == nil {
		onError = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					options := protojson.MarshalOptions{UseProtoNames: true}
					buf, err := options.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == "" {
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		arg := &ValidatePurchaseAlipayRequest{}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				onError(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := protojson.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				onError(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/appsets.api.v1.PurchaseService/ValidatePurchaseAlipay",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.ValidatePurchaseAlipay(c, req.(*ValidatePurchaseAlipayRequest))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			onError(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*ValidatePurchaseAlipayResponse)
		if !ok {
			onError(ctx, w, r, arg, nil, fmt.Errorf("/appsets.api.v1.PurchaseService/ValidatePurchaseAlipay: interceptors have not return ValidatePurchaseAlipayResponse"))
			return
		}

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			options := protojson.MarshalOptions{UseProtoNames: true}
			buf, err := options.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			onError(ctx, w, r, arg, ret, err)
			return
		}
		onError(ctx, w, r, arg, ret, nil)
	})
}

// ValidatePurchaseAlipayWithName returns Service name, Method name and PurchaseServiceHTTPService interface's ValidatePurchaseAlipay converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) ValidatePurchaseAlipayWithName(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	return "PurchaseService", "ValidatePurchaseAlipay", h.ValidatePurchaseAlipay(onError, interceptors...)
}

// ValidatePurchaseAlipayHTTPRule returns HTTP method, path and PurchaseServiceHTTPService interface's ValidatePurchaseAlipay converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) ValidatePurchaseAlipayHTTPRule(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	if onError == nil {
		onError = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					options := protojson.MarshalOptions{UseProtoNames: true}
					buf, err := options.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.MethodPost, "/api/v1/purchase/alipay/validate", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == "" {
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		arg := &ValidatePurchaseAlipayRequest{}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				onError(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := protojson.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				onError(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/appsets.api.v1.PurchaseService/ValidatePurchaseAlipay",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.ValidatePurchaseAlipay(c, req.(*ValidatePurchaseAlipayRequest))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			onError(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*ValidatePurchaseAlipayResponse)
		if !ok {
			onError(ctx, w, r, arg, nil, fmt.Errorf("/appsets.api.v1.PurchaseService/ValidatePurchaseAlipay: interceptors have not return ValidatePurchaseAlipayResponse"))
			return
		}

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			options := protojson.MarshalOptions{UseProtoNames: true}
			buf, err := options.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			onError(ctx, w, r, arg, ret, err)
			return
		}
		onError(ctx, w, r, arg, ret, nil)
	})
}

// CancelPurchase returns PurchaseServiceHTTPService interface's CancelPurchase converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) CancelPurchase(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) http.HandlerFunc {
	if onError == nil {
		onError = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					options := protojson.MarshalOptions{UseProtoNames: true}
					buf, err := options.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == "" {
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		arg := &CancelPurchaseRequest{}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				onError(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := protojson.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				onError(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/appsets.api.v1.PurchaseService/CancelPurchase",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.CancelPurchase(c, req.(*CancelPurchaseRequest))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			onError(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*CancelPurchaseResponse)
		if !ok {
			onError(ctx, w, r, arg, nil, fmt.Errorf("/appsets.api.v1.PurchaseService/CancelPurchase: interceptors have not return CancelPurchaseResponse"))
			return
		}

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			options := protojson.MarshalOptions{UseProtoNames: true}
			buf, err := options.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			onError(ctx, w, r, arg, ret, err)
			return
		}
		onError(ctx, w, r, arg, ret, nil)
	})
}

// CancelPurchaseWithName returns Service name, Method name and PurchaseServiceHTTPService interface's CancelPurchase converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) CancelPurchaseWithName(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	return "PurchaseService", "CancelPurchase", h.CancelPurchase(onError, interceptors...)
}

// CancelPurchaseHTTPRule returns HTTP method, path and PurchaseServiceHTTPService interface's CancelPurchase converted to http.HandlerFunc.
func (h *PurchaseServiceHTTPConverter) CancelPurchaseHTTPRule(onError func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	if onError == nil {
		onError = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					options := protojson.MarshalOptions{UseProtoNames: true}
					buf, err := options.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.MethodPost, "/api/v1/purchase/cancel", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == "" {
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		arg := &CancelPurchaseRequest{}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				onError(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := protojson.Unmarshal(body, arg); err != nil {
					onError(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				onError(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/appsets.api.v1.PurchaseService/CancelPurchase",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.CancelPurchase(c, req.(*CancelPurchaseRequest))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			onError(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*CancelPurchaseResponse)
		if !ok {
			onError(ctx, w, r, arg, nil, fmt.Errorf("/appsets.api.v1.PurchaseService/CancelPurchase: interceptors have not return CancelPurchaseResponse"))
			return
		}

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			options := protojson.MarshalOptions{UseProtoNames: true}
			buf, err := options.Marshal(ret)
			if err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				onError(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			onError(ctx, w, r, arg, ret, err)
			return
		}
		onError(ctx, w, r, arg, ret, nil)
	})
}
